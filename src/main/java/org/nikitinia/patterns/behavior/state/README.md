# Состояние (State)
* [К описанию проекта](https://github.com/engine-it-in/java-design-patterns)
## Тип
* Поведенческий шаблон;
## Назначение
* Шаблон назначен для возможности изменения поведения, в зависимости 
от состояния объекта. 
## Суть
* У каждого объекта могут быть разные состояния. Каждое состояние характеризует
изменение объекта во времени. Набор состояний должен быть конечен. Каждое состояние
должно быть определено. В разных состояния объект может по разному реагировать на 
одни и те же события;
## Контекст применения
* Использование этого паттерна востребовано для ситуаций, в которых 
актуально применять оператор `switch` - оператор сравнения по конкретному значению.
Когда реализуемая Вами логика ограничена и понятна - в этом нет проблемы, но когда
логика начинает разрастаться набольшое количество сравниваемых состояний, то 
Вы увиличиваете параметры сравнения, что потенциально будет являться местом 
возникновения лапши-кода;
## Применимость
* Этот шаблон предполагает создание отдельных классов на каждое состояние, 
в котором может находиться объект. Классы реализуют соответсвующее 
состояние объекта, то есть вместо того, чтобы хранить состояния и их поведение 
в одном классе, вы делегируете и инкапсулируете изменения в конкретные классы;
## Какой функционал предоставляет
* Этот шаблон проектирования представляет возможность гибкого масштабирования кода.
В случае наличия нового состояния у объекта, Вы выносите его в конкретный класс.
Так Вы соблюдаете инкапсуляцию и сохроняете структурированность Вашего кода.;
## Преимущества и недостатки при использовании
| Преимущества                                                                         | Недостатки                                                      |
|--------------------------------------------------------------------------------------|-----------------------------------------------------------------|
| Концентрируется в одном месте, из которого выполняется оркестрация логикой состояний | Если изменяющихся состояний мало, то приводит к усложнению кода |
## Алгоритм реализации
* Выделяем класс контекст в котором происходит маршрутизация состояний;
* Выделение общего интерфейса состояний;
* Для каждого состояния необходим класс, реализающий общий интерфейс;
* В классе контексте поля для хранения состояний и методы для доступа к ним;
# Формулировка задачи
* Допустим, что каждый документ, может находится в двух разных состояниях. 
Каждое состояние характеризуется реестром того, какие документы в нем находились (
каждый документ может назодиться в реестре один раз), сменой статуса -> 
если первое состояние - статус Предподписание, если второе состояние - статус Подписан. 
При смене состояния необходимо уведомлять о том, документ с каким номером и статусом,
в нем находился. После смены всех состояний необходимо в консоль распечатать 
информацию о том, какой/какие документы находились в реестре. Требуется у конкретного
документа запустить в цикле, 10 раз, процесс смены состяний. При нахождении 
в каждом состоянии требуется печатать информацию о документе и в конце распечатать
информацию о реестре.