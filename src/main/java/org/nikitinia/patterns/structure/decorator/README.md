# Декоратор (Decorator)

* [К описанию проекта](https://github.com/engine-it-in/java-design-patterns)

## Тип

* Структурный шаблон;

## Назначение

* Позволяет добавлять объектам новое поведение,
  оборачивая их в новую функциональность;

## Суть

* Построен на механизме композиции или агерегации, как механизме наследования поведения, которое требуется
  изменить/дополнить;
* Альтернативное название шаблона декоратор - Обертка. Оно раскрывает суть шаблона декоратор. Исходный класс, поведение
  которого нужно дополнить, оборачивается в объект и обрабатывается/дополняется в классе обертке;

## Контекст применения

* Для добавления поведения классу в процессе его использования;

## Применимость

* Когда требуется добавлять поведение классу в процессе его использования,
  незаметно для других частей, использующих первоначальный класс;
* Когда нельзя расширить обязанности объекта путем наследования, например, работая с финальными классами;

## Какой функционал предоставляет

* Разбиение общей логики на набор классов, каждый 
из которых реализует определеный набор действий;
* Возможность добавление логики к финальным классам;

## Преимущества и недостатки при использовании

| Преимущества                                                     | Недостатки               |
|------------------------------------------------------------------|--------------------------|
| Высокая гибкость                                                 | Сложное конфигурирование |
| Возможность добавления обязанностей в процессе исполнения        | Обилие классов           |
| Несколько небольших связанных объектов вместо одного монолитного |                          |

## Алгоритм реализации

* Создать интерфейс, который описывает методы, как для компонента, так и для его дополнений;
* Создать класс декораторов, который должен иметь ссылки на конкретные компоненты;
* Все методы декоратора должны делегировать действий декорируемому классу;
* Компонент и декоратор должны следовать единому интерфейсу;
* Создать классы декораторв, которые наследуются от базового декоратора. Конкретный декоратор должен выполнять свою
  функцию
  и в процессе выполнения вызывать базовый метод основного класса;
* Клиент берет на себя обязанности по конфигурированию и иерархической работе с объектами;

# Формулировка задачи

* ?;